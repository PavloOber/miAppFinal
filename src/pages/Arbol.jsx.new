import { useFamilia } from "../context/familiaContext";
import * as d3 from "d3";
import "../styles/Arbol.css";
import { useRef, useEffect } from "react";

// Símbolos Unicode
const HEART_SYMBOL = "\u2764"; // Símbolo de corazón Unicode
const MALE_SYMBOL = "\u2642"; // Símbolo masculino Unicode
const FEMALE_SYMBOL = "\u2640"; // Símbolo femenino Unicode

const Arbol = () => {
  const { familiares } = useFamilia();
  const svgRef = useRef(null);

  // Función para crear los datos del árbol genealógico
  const createFamilyTreeData = (familiares) => {
    // Crear un mapa para acceder rápidamente a los familiares por ID
    const familiaresMap = new Map();
    
    // Conjunto para rastrear los IDs que ya han sido añadidos al árbol
    const addedToTree = new Set();
    
    // Crear nodos para cada familiar
    familiares.forEach(familiar => {
      const nodo = {
        id: familiar.id,
        nombre: familiar.nombre,
        apellido: familiar.apellido,
        genero: familiar.genero,
        children: [],
        esPareja: false,
        parejaId: familiar.conyugeId
      };
      
      familiaresMap.set(familiar.id, nodo);
    });
    
    // Marcar nodos que son parte de una pareja
    familiares.forEach(familiar => {
      if (familiar.conyugeId && familiaresMap.has(familiar.conyugeId)) {
        const nodo = familiaresMap.get(familiar.id);
        const conyugeNodo = familiaresMap.get(familiar.conyugeId);
        
        // Marcar ambos como parte de una pareja
        nodo.esPareja = true;
        nodo.parejaId = familiar.conyugeId;
        conyugeNodo.esPareja = true;
        conyugeNodo.parejaId = familiar.id;
        
        console.log(`Marcada pareja: ${nodo.nombre} y ${conyugeNodo.nombre}`);
      }
    });
    
    // Añadir hijos a los padres
    familiares.forEach(familiar => {
      if (familiar.hijosIds && familiar.hijosIds.length > 0) {
        const padreNode = familiaresMap.get(familiar.id);
        
        familiar.hijosIds.forEach(hijoId => {
          if (familiaresMap.has(hijoId)) {
            const hijoNode = familiaresMap.get(hijoId);
            
            // Añadir hijo al padre
            padreNode.children.push(hijoNode);
            
            // Marcar como añadido al árbol
            addedToTree.add(hijoId);
            
            console.log(`Añadido ${hijoNode.nombre} como hijo de ${padreNode.nombre}`);
          }
        });
        
        // Marcar al padre como añadido al árbol
        addedToTree.add(familiar.id);
      }
    });
    
    // Encontrar las raíces (nodos que no son hijos de nadie)
    const roots = [];
    
    // Primero añadir nodos que tienen hijos pero no han sido añadidos como hijos de otros
    familiares.forEach(familiar => {
      if (!addedToTree.has(familiar.id) && familiar.hijosIds && familiar.hijosIds.length > 0) {
        const familiarNode = familiaresMap.get(familiar.id);
        roots.push(familiarNode);
        addedToTree.add(familiar.id);
        console.log(`Añadido ${familiar.nombre} como raíz (tiene hijos)`);
      }
    });
    
    // Luego añadir cualquier nodo que no haya sido procesado
    familiares.forEach(familiar => {
      if (!addedToTree.has(familiar.id)) {
        const familiarNode = familiaresMap.get(familiar.id);
        roots.push(familiarNode);
        addedToTree.add(familiar.id);
        console.log(`Añadido ${familiar.nombre} como raíz individual (no procesado previamente)`);
      }
    });

    // Si hay múltiples raíces, crear un nodo raíz artificial
    if (roots.length > 1) {
      return {
        nombre: "Familia",
        id: "root",
        children: roots
      };
    } else if (roots.length === 1) {
      return roots[0];
    } else {
      // Si no hay raíces (caso raro), devolver un nodo vacío
      return {
        nombre: "No hay datos",
        children: []
      };
    }
  };

  useEffect(() => {
    if (!familiares.length) return;

    // Limpiar el SVG antes de dibujar
    d3.select(svgRef.current).selectAll("*").remove();

    // Imprimir los datos de los familiares para depuración
    console.log("Datos de familiares:", familiares);
    
    // Imprimir información detallada de cada familiar
    familiares.forEach(familiar => {
      console.log(`Familiar: ${familiar.nombre} ${familiar.apellido} (ID: ${familiar.id})`);
      console.log(`  - Género: ${familiar.genero}`);
      console.log(`  - Cónyuge ID: ${familiar.conyugeId}`);
      console.log(`  - Hijos IDs: ${JSON.stringify(familiar.hijosIds)}`);
      console.log(`  - Padres IDs: ${JSON.stringify(familiar.padresIds)}`);
    });
    
    // Crear datos para el árbol
    const treeData = createFamilyTreeData(familiares);
    console.log("Datos del árbol:", treeData);

    // Configurar el árbol
    const width = 1000;
    const height = 800;
    const margin = { top: 40, right: 90, bottom: 50, left: 90 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    // Crear el contenedor SVG
    const svg = d3.select(svgRef.current)
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Crear el layout del árbol
    const treeLayout = d3.tree()
      .size([innerWidth, innerHeight])
      .separation((a, b) => {
        // Aumentar la separación entre nodos que son pareja
        if (a.data.esPareja && b.data.esPareja && a.data.parejaId === b.data.id) {
          return 1.2; // Parejas más juntas
        }
        return a.parent === b.parent ? 1.5 : 2.5;
      });

    // Crear la jerarquía del árbol
    const root = d3.hierarchy(treeData);
    
    // Asignar posiciones a cada nodo
    treeLayout(root);

    // Dibujar las líneas de conexión
    svg.selectAll(".link")
      .data(root.links())
      .enter()
      .append("path")
      .attr("class", "link")
      .attr("d", d3.linkVertical()
        .x(d => d.x)
        .y(d => d.y)
      );

    // Dibujar líneas especiales entre cónyuges
    const parejasLinks = [];
    root.descendants().forEach(node => {
      if (node.data.esPareja && node.data.parejaId) {
        // Buscar el nodo de la pareja
        const parejaNode = root.descendants().find(n => n.data.id === node.data.parejaId);
        if (parejaNode && node.data.id < parejaNode.data.id) { // Evitar duplicados
          parejasLinks.push({
            source: node,
            target: parejaNode
          });
        }
      }
    });

    // Dibujar líneas de corazón entre parejas
    svg.selectAll(".link-pareja")
      .data(parejasLinks)
      .enter()
      .append("path")
      .attr("class", "link-pareja")
      .attr("d", d => {
        // Crear una línea curva entre las parejas
        const midX = (d.source.x + d.target.x) / 2;
        const midY = (d.source.y + d.target.y) / 2;
        return `M${d.source.x},${d.source.y} Q${midX},${midY-15} ${d.target.x},${d.target.y}`;
      });

    // Dibujar corazones entre parejas
    svg.selectAll(".heart")
      .data(parejasLinks)
      .enter()
      .append("text")
      .attr("class", "heart-symbol")
      .attr("x", d => (d.source.x + d.target.x) / 2)
      .attr("y", d => (d.source.y + d.target.y) / 2 - 10)
      .attr("text-anchor", "middle")
      .text(HEART_SYMBOL);

    // Crear grupos para los nodos
    const nodes = svg.selectAll(".node")
      .data(root.descendants())
      .enter()
      .append("g")
      .attr("class", d => {
        let classes = "node";
        if (d.data.esPareja) classes += " node-pareja";
        if (d.data.genero === "hombre") classes += " node-hombre";
        if (d.data.genero === "mujer") classes += " node-mujer";
        return classes;
      })
      .attr("transform", d => `translate(${d.x},${d.y})`);

    // Dibujar círculos para los nodos
    nodes.append("circle")
      .attr("r", 30);

    // Añadir nombres a los nodos
    nodes.append("text")
      .attr("dy", 50)
      .attr("text-anchor", "middle")
      .text(d => d.data.nombre);
      
    // Añadir símbolos de género si están definidos
    nodes.each(function(d) {
      if (d.data.genero === "hombre") {
        d3.select(this).append("text")
          .attr("class", "gender-symbol male")
          .attr("dy", -40)
          .attr("text-anchor", "middle")
          .text(MALE_SYMBOL);
      } else if (d.data.genero === "mujer") {
        d3.select(this).append("text")
          .attr("class", "gender-symbol female")
          .attr("dy", -40)
          .attr("text-anchor", "middle")
          .text(FEMALE_SYMBOL);
      }
    });
  }, [familiares]);

  return (
    <div className="arbol-container">
      <h2 className="text-2xl font-bold mb-4">Árbol Genealógico</h2>
      <div className="arbol-svg-container">
        <svg ref={svgRef} className="arbol-svg"></svg>
      </div>
    </div>
  );
};

export default Arbol;
